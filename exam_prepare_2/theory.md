# Теория для подготовки к экзамену по си в 3 семестре

- [Теория для подготовки к экзамену по си в 3 семестре](#теория-для-подготовки-к-экзамену-по-си-в-3-семестре)
- [1. Указатель на void. Стандартные функции обработки](#1-указатель-на-void-стандартные-функции-обработки)
  - [Используется](#используется)
  - [Особенности использования](#особенности-использования)
  - [Функции обработки памяти](#функции-обработки-памяти)
- [Функции динамического выделения памяти.](#функции-динамического-выделения-памяти)
  - [Особенности](#особенности)
  - [Описание функций](#описание-функций)
  - [+/- Явного приведения](#--явного-приведения)
  - [Выделение 0 Байт памяти](#выделение-0-байт-памяти)
  - [Обработка NULL, возвращаемого функцией // Подходы к обработке ситуации отсутствия свободной памяти при выделении.](#обработка-null-возвращаемого-функцией--подходы-к-обработке-ситуации-отсутствия-свободной-памяти-при-выделении)
  - [Выделение памяти под динамический массив, передача массива в функцию. Типичные ошибки при работе с динамической памятью](#выделение-памяти-под-динамический-массив-передача-массива-в-функцию-типичные-ошибки-при-работе-с-динамической-памятью)




# 1. Указатель на void. Стандартные функции обработки 
## Используется
```Для чего используется указатель на void? Приведите примеры.
Каковы особенности использования указателя на void? Приведите примеры.
Функции memcpy, memmove, memcmp, memset: назначение, особенности использования
примеры использования
```

Указатель на void используется для 
- Ссылки на произвольный участок памяти, независимо от его содержимого  
`void *memcpy(void *dst, const void *src, size_t n)`  
Таким образом, нас интерисует только то, где размещается память и ее размер  
- Позволяет передать в функцию указатель на объект любого типа (кроме указателя на функцию)  
`void qsort(void *arr, size_t number, size_t size, int (*comparator)(const void *l, const void *r))`

## Особенности использования
- Допускаивается присваивание без явного приведения типов
```c
int a = 1;
int *pa = &a;
void *pv = pa;
int *pb = pv;
```
- Указатель на void нельзя разыменовать, так неизвестен размер того типа, на который он указывает
- Указатель на void нельзя привести к указателю на функцию (можно через костыль) и наоброт. `*(void **)pfunc = pvoid;`
- К указателю на void не применима адрессная арифметика, так как не известен его размер.

## Функции обработки памяти
| Функция                                                                     | Описание                                                                                                                                                                                                                                              |
| --------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `void *memcpy(void *restrict dst, const void *restrict src, size_t count) ` | Копирует `count` байтов блока памяти `src`, во второй блок памяти `dst`. `UB` при - Перекрывании блоков памяти - Неделйствительных блоков. Возвращает указатель на `dst`                                                                              |
| `void *memove(void *restrict dst, const void *src, size_t count)`           | Функция копирует число байт `count` из `src` в `dst`. Возвращается указатель на `dst`. Копирование происходит через буфер, что позволяет исользовать функцию при перекрытии областей памяти. `UB` при недействительных указателях.                    |
| `int memcmp(const void *s_1, const void *s_2, size_t count)`                | Сравнивает первые `count` байт блока памяти указателя `s_1` с первыми `count` байт блока памяти указателя `s_2`. `UB` При -недействительных указателях.<br>Возвращает - 0: Содержимое равно<br> > 0 - Первый блок больше<br>< 0  - Второй блок больше |
| `void *memset(void *dst, int c, size_t n)`                                  | Заполняет `count` байт по адресу `dst` символом `c`. Возвращает указатель на `dst`.                                                                                                                                                                   |


# Функции динамического выделения памяти.
```
Функции для выделения и освобождения памяти malloc, calloc, free.
Порядок работы и особенности использования этих функций.
Функция realloc. Особенности использования.
Общие «свойства» функций malloc, calloc, realloc.
Функция выделения памяти и явное приведение типа: за и против.
Особенности выделения 0 байт памяти.
Способы возвращения динамического массива из функции.
Типичные ошибки при работе с динамической памятью (классификация, примеры).
Подходы к обработке ситуации отсутствия свободной памяти при выделении.
```
## Особенности
- Все функции находятся в `stdlib.h`
- Функции не создают переменную, они лишь выделяют область памяти
- В качестве результата функции возвращают адрес расположения этой области в памяти компьютера, те `указатель`
- Возвращается указатель на `void`
- В случае ошибки при выделении памяти возвращется `NULL`
- После использования необходимо освободить память с помощью `free()`

## Описание функций
![alt text](images/1.png)
## +/- Явного приведения
`char *string = (char *)malloc(10);`
| +                                                  | -                                                                   |
| -------------------------------------------------- | ------------------------------------------------------------------- |
| Совместимость с C++                                | Начиная с `ANSI C` приведение не нужно                              |
| У `malloc` до `ANSI` C был прототип `char *malloc` | Может скрыться ошибка, если не подключен `stdlib.h`                 |
| Дополнительная самопроверка                        | В случае изменения типа указателя, придется менять тип в приведении |

## Выделение 0 Байт памяти
Результата вызова `malloc`, `calloc` и `realloc`, когда запрашиваемый размер блока равен 0 байт, зависит от компилятора.
- Вернет нулевой указатель
- Вернется "Нормальный" указатель, но его нельзя использовать для разыменования
Поэтомуц перед вызовом нужно проверить размер.

В случае `realloc`, при 0 байт, функция будет работать как `free()`

## Обработка NULL, возвращаемого функцией // Подходы к обработке ситуации отсутствия свободной памяти при выделении.
- Отладчик Valgrind
- Возвращаение ошибки
- Ошибка сегментации (segfault)
- Аварийное завершение (abort)
- Восстановление (recovery) - `xmalloc` из git

## Выделение памяти под динамический массив, передача массива в функцию. Типичные ошибки при работе с динамической памятью 
Можно передавать как возвращаемое значение, а можно пол указателю
```c
int create_arr(int **arr, size_t count);
int *create_arr(size_t count);
```
Типичные ошибки  
- Неверный расчет кол-ва выделяемой памяти 
- Отсутствие проверки на NULL после выделения памяти 
- Утечки памяти 
- Wild pointer: использование неинициализированного указателя 
- Dangling pointer: использование указателя сразу же после освобождения 
- Изменение указателя, который вернула функция выделения памяти
- Двойное освобождение памяти 
- Освобождение не выделенной памяти или не динамической памяти
- Выход за границы динамического массива

