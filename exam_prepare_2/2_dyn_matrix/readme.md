# Практика темы "Динамические матрицы"

## 1. Матрица как одномерный массив
![alt text](pictures/1.png)
Представление в памяти
![alt text](pictures/2.png)

**Выделение памяти**
```c
err_t create_matrix(matrix_t *matrix, int n, int m)
{
    if (n < 1 || m < 1)
    {
        return ERR_SIZE;
    }
    if (matrix == NULL)
        return ERR_ARGS;

    matrix->matrix = malloc(sizeof(int) * n * m);
    if (matrix->matrix == NULL)
        return ERR_MEM_ALLOC;

    matrix->n = (size_t)n;
    matrix->m = (size_t)m;
    return ERR_OK;
}
```

**Освобождение памяти**
```c
void free_matrix(matrix_t *matrix)
{
    if (matrix->matrix)
    {
        free(matrix->matrix);
    }
}
```

**Обращение к элементам**
```c
matrix.matrix[i * matrix.n + j]
```

### Примущества
- Простота выделения памяти
- Возможность использовать, как одномерный массив

### Недостатки
- Отладчик использованя памяти (valgrind) не может отследить обращение за пределы строки
- Нужно писать `[i * n + j]` – Нет синтаксического сахара

## 2. Матрица как массив указателей
Иной подход, мы выделяем память под массив указателей. В массиве будут храниться указатели на выделенные массивы для строк матрицы (массив)
![alt text](pictures/3.png)

Представление в памяти – указатель на массив хранится в стеке, все остальное в куче.
![alt text](pictures/4.png)


### Примущества
Исправляются недостатки предыдущего способа
- Можно обращаться к элементам a[i][j]
- Отладчики памяти `(valgrind)` могут отследить выход за пределы массива
### Недостатки
- Используется бОльший объем памяти, чем при статическом выделении памяти, из-за того что нужно хранить массив указателей
- *(Из лекции) Сложность выделения и освобождения памяти (хз где сложность)*
- Память под матрицу не лежит одной областью

# Источники
1. Лекции МГТУ им Н.Э. Баумана, каф. Программная Инженерия.